import { Injectable, Logger, BadRequestException, InternalServerErrorException, Scope } from '@nestjs/common';
// const { PrismaClient: TenantPrismaClient } = require('../../../generated/prisma');
import prisma from '../../lib/prisma';
import * as crypto from 'crypto';

interface TenantContext {
  tenantId: string;
  userId: string;
  dbName: string;
  role: string;
}

interface ConnectionHealth {
  tenantId: string;
  isConnected: boolean;
  lastChecked: Date;
  connectionCount: number;
  error?: string;
}

@Injectable({ scope: Scope.REQUEST })
export class TenantPrismaService {
  private readonly logger = new Logger(TenantPrismaService.name);
  private static tenantConnections = new Map<string, any>();
  private static connectionHealth = new Map<string, ConnectionHealth>();
  private readonly encryptionKey = process.env.ENCRYPTION_KEY || 'default-key-change-in-production';
  
  private currentTenantContext?: TenantContext;

  constructor() {
    // Set up periodic health checks
    this.setupHealthChecks();
  }

  /**
   * Set tenant context from JWT payload
   */
  setTenantContext(context: TenantContext): void {
    this.currentTenantContext = context;
    this.logger.debug(`Tenant context set: ${context.tenantId}`);
  }

  /**
   * Get current tenant context
   */
  getTenantContext(): TenantContext {
    if (!this.currentTenantContext) {
      throw new BadRequestException('Tenant context not set. Ensure JWT middleware is properly configured.');
    }
    return this.currentTenantContext;
  }

  /**
   * Get Prisma client for current tenant
   */
  async getTenantClient(): Promise<any> {
    const context = this.getTenantContext();
    return this.getTenantClientById(context.tenantId);
  }

  /**
   * Alias for getTenantClientById for compatibility
   */
  async getClient(tenantId: string): Promise<any> {
    return this.getTenantClientById(tenantId);
  }

  /**
   * Get Prisma client for specific tenant
   */
  async getTenantClientById(tenantId: string): Promise<any> {
    // Check if connection already exists and is healthy
    if (TenantPrismaService.tenantConnections.has(tenantId)) {
      const client = TenantPrismaService.tenantConnections.get(tenantId)!;
      
      // Verify connection health
      if (await this.isConnectionHealthy(tenantId, client)) {
        return client;
      } else {
        // Remove unhealthy connection
        await this.disconnectTenant(tenantId);
      }
    }

    // Create new connection
    return this.createTenantConnection(tenantId);
  }

  /**
   * Create new tenant connection
   */
  private async createTenantConnection(tenantId: string): Promise<any> {
    this.logger.log(`Creating new connection for tenant: ${tenantId}`);

    try {
      // Get tenant configuration from SuperAdmin DB
      const tenant = await prisma.tenant.findUnique({
        where: { id: tenantId },
        select: {
          id: true,
          slug: true,
          dbHost: true,
          dbPort: true,
          dbName: true,
          dbUsername: true,
          dbPasswordEncrypted: true,
          dbConnectionPoolSize: true,
          isActive: true,
          isSuspended: true,
        },
      });

      if (!tenant) {
        throw new BadRequestException(`Tenant not found: ${tenantId}`);
      }

      if (!tenant.isActive || tenant.isSuspended) {
        throw new BadRequestException(`Tenant is not active or suspended: ${tenant.slug}`);
      }

      // Decrypt password and build connection URL
      const decryptedPassword = this.decryptPassword(tenant.dbPasswordEncrypted);
      const connectionUrl = this.buildConnectionUrl(tenant, decryptedPassword);

      // Create Prisma client with tenant-specific configuration
      // const tenantClient = new TenantPrismaClient({
      //   datasources: {
      //     db: {
      //       url: connectionUrl,
      //     },
      //   },
      //   log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
      // });
      const tenantClient = null; // Temporarily disabled

      // Test connection
      // await tenantClient.$connect();
      
      // Store connection and health info
      // TenantPrismaService.tenantConnections.set(tenantId, tenantClient);
      
      // Temporarily return null
      return null;
      TenantPrismaService.connectionHealth.set(tenantId, {
        tenantId,
        isConnected: true,
        lastChecked: new Date(),
        connectionCount: 1,
      });

      this.logger.log(`Successfully connected to tenant database: ${tenant.slug}`);
      return tenantClient;

    } catch (error) {
      this.logger.error(`Failed to create tenant connection: ${tenantId}`, error.stack);
      
      // Store error in health info
      TenantPrismaService.connectionHealth.set(tenantId, {
        tenantId,
        isConnected: false,
        lastChecked: new Date(),
        connectionCount: 0,
        error: error.message,
      });

      throw new InternalServerErrorException(`Failed to connect to tenant database: ${error.message}`);
    }
  }

  /**
   * Build connection URL for tenant
   */
  private buildConnectionUrl(tenant: any, password: string): string {
    const poolSize = tenant.dbConnectionPoolSize || 10;
    return `postgresql://${tenant.dbUsername}:${password}@${tenant.dbHost}:${tenant.dbPort}/${tenant.dbName}?schema=public&connection_limit=${poolSize}&pool_timeout=20&connect_timeout=10`;
  }

  /**
   * Check if connection is healthy
   */
  private async isConnectionHealthy(tenantId: string, client: any): Promise<boolean> {
    try {
      // Simple query to test connection
      await client.$queryRaw`SELECT 1`;
      
      // Update health status
      const health = TenantPrismaService.connectionHealth.get(tenantId);
      if (health) {
        health.isConnected = true;
        health.lastChecked = new Date();
        health.error = undefined;
      }
      
      return true;
    } catch (error) {
      this.logger.warn(`Connection health check failed for tenant: ${tenantId}`, error.message);
      
      // Update health status
      const health = TenantPrismaService.connectionHealth.get(tenantId);
      if (health) {
        health.isConnected = false;
        health.lastChecked = new Date();
        health.error = error.message;
      }
      
      return false;
    }
  }

  /**
   * Disconnect specific tenant
   */
  async disconnectTenant(tenantId: string): Promise<void> {
    const client = TenantPrismaService.tenantConnections.get(tenantId);
    if (client) {
      try {
        await client.$disconnect();
        this.logger.log(`Disconnected tenant: ${tenantId}`);
      } catch (error) {
        this.logger.warn(`Error disconnecting tenant: ${tenantId}`, error.message);
      }
      
      TenantPrismaService.tenantConnections.delete(tenantId);
      TenantPrismaService.connectionHealth.delete(tenantId);
    }
  }

  /**
   * Disconnect all tenants
   */
  static async disconnectAllTenants(): Promise<void> {
    const disconnectPromises = Array.from(TenantPrismaService.tenantConnections.keys()).map(
      async (tenantId) => {
        const client = TenantPrismaService.tenantConnections.get(tenantId);
        if (client) {
          try {
            await client.$disconnect();
          } catch (error) {
            console.warn(`Error disconnecting tenant: ${tenantId}`, error.message);
          }
        }
      }
    );
    
    await Promise.all(disconnectPromises);
    TenantPrismaService.tenantConnections.clear();
    TenantPrismaService.connectionHealth.clear();
  }

  /**
   * Get connection health status for all tenants
   */
  getConnectionsHealth(): ConnectionHealth[] {
    return Array.from(TenantPrismaService.connectionHealth.values());
  }

  /**
   * Get connection health for specific tenant
   */
  getTenantHealth(tenantId: string): ConnectionHealth | undefined {
    return TenantPrismaService.connectionHealth.get(tenantId);
  }

  /**
   * Get active connections count
   */
  getActiveConnectionsCount(): number {
    return TenantPrismaService.tenantConnections.size;
  }

  /**
   * Setup periodic health checks
   */
  private setupHealthChecks(): void {
    // Run health checks every 5 minutes
    setInterval(async () => {
      await this.performHealthChecks();
    }, 5 * 60 * 1000);

    // Cleanup inactive connections every 30 minutes
    setInterval(async () => {
      await this.cleanupInactiveConnections();
    }, 30 * 60 * 1000);
  }

  /**
   * Perform health checks on all connections
   */
  private async performHealthChecks(): Promise<void> {
    const tenantIds = Array.from(TenantPrismaService.tenantConnections.keys());
    
    for (const tenantId of tenantIds) {
      const client = TenantPrismaService.tenantConnections.get(tenantId);
      if (client) {
        await this.isConnectionHealthy(tenantId, client);
      }
    }
  }

  /**
   * Cleanup inactive connections
   */
  private async cleanupInactiveConnections(): Promise<void> {
    const now = new Date();
    const maxInactiveTime = 30 * 60 * 1000; // 30 minutes

    for (const [tenantId, health] of TenantPrismaService.connectionHealth.entries()) {
      const timeSinceLastCheck = now.getTime() - health.lastChecked.getTime();
      
      if (!health.isConnected || timeSinceLastCheck > maxInactiveTime) {
        this.logger.log(`Cleaning up inactive connection for tenant: ${tenantId}`);
        await this.disconnectTenant(tenantId);
      }
    }
  }

  /**
   * Decrypt password using AES-256-CBC
   */
  private decryptPassword(encryptedPassword: string): string {
    try {
      const algorithm = 'aes-256-cbc';
      const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);
      
      const parts = encryptedPassword.split(':');
      if (parts.length !== 2) {
        throw new Error('Invalid encrypted password format');
      }
      
      const iv = Buffer.from(parts[0], 'hex');
      const encrypted = parts[1];
      
      const decipher = crypto.createDecipheriv(algorithm, key, iv);
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      
      return decrypted;
    } catch (error) {
      this.logger.error('Failed to decrypt password', error.stack);
      throw new InternalServerErrorException('Failed to decrypt database credentials');
    }
  }

  /**
   * Execute transaction with current tenant client
   */
  async executeTransaction<T>(
    callback: (client: any) => Promise<T>
  ): Promise<T> {
    const client = await this.getTenantClient();
    return client.$transaction(callback);
  }

  /**
   * Execute raw query with current tenant client
   */
  async executeRawQuery<T = any>(query: string, params?: any[]): Promise<T> {
    const client = await this.getTenantClient();
    return client.$queryRawUnsafe(query, ...(params || []));
  }

  /**
   * Get tenant database statistics
   */
  async getTenantDatabaseStats(tenantId?: string): Promise<any> {
    const targetTenantId = tenantId || this.getTenantContext().tenantId;
    const client = await this.getTenantClientById(targetTenantId);

    try {
      // Get basic database statistics
      const stats = await client.$queryRaw`
        SELECT 
          schemaname,
          tablename,
          n_tup_ins as inserts,
          n_tup_upd as updates,
          n_tup_del as deletes,
          n_live_tup as live_tuples,
          n_dead_tup as dead_tuples
        FROM pg_stat_user_tables
        ORDER BY n_live_tup DESC
        LIMIT 20
      `;

      return {
        tenantId: targetTenantId,
        tables: stats,
        connectionHealth: this.getTenantHealth(targetTenantId),
        timestamp: new Date(),
      };
    } catch (error) {
      this.logger.error(`Failed to get database stats for tenant: ${targetTenantId}`, error.stack);
      throw new InternalServerErrorException('Failed to retrieve database statistics');
    }
  }
}

// Cleanup connections on process exit
process.on('beforeExit', async () => {
  await TenantPrismaService.disconnectAllTenants();
});

process.on('SIGINT', async () => {
  await TenantPrismaService.disconnectAllTenants();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await TenantPrismaService.disconnectAllTenants();
  process.exit(0);
});